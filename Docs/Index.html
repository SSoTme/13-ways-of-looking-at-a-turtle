<html><head><title>One way of Looking at 13 Ways of Looking At A Turtle</title><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" integrity="sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M" crossorigin="anonymous" /></head><body style="padding: 1em; font-size: 0.9em;"><h1>One Way of Looking at</h1><h2>13 ways of looking at a turtle</h2><div><p>
                This fork of <a href="https://github.com/swlaschin/13-ways-of-looking-at-a-turtle">13 Ways of looking at a Turtl</a>.  This
                Fantastic <a href="http://fsharpforfunandprofit.com/posts/13-ways-of-looking-at-a-turtle/">Article/Blog Post</a>
                inspired me to use it has the basis for demonstrating the power of having a
                Single Source of Truth (SSoT) when developing software.
            </p><p>The code can be found on <a href="https://github.com/eejai42/13-ways-of-looking-at-a-turtle">GitHub</a>.</p><p>
                The purpose of the original article, was to demonstrate 13 different ways
                to solve the same problem.  The reason this is such a great starting
                place to domonstrate the SSoT toolset, is that "the code" is what it is.
                In other words, the decision of what the code should be is already decided.
            </p><p>
                The question asked by this fork of the repo is, what would be the best way to 
                Create/Manage that code in a "production" environment.
            </p><p>
                The code in this branch have been created by following the following steps
                in an iterative fashion.  To begin with, I created an empty Single Source
                of Truth (<b>SSoT</b>) in the form of a <a href="https://docs.google.com/spreadsheets/d/1kjyb0JGswSufELAKuy5jtuhs6I0ZyvY9Zwa5Nei6aAo/edit#gid=1093073527" target="_13wgsheet">Google Spreadsheet</a>. 
                This SSoT serves as the place to put decisions.  Specifically, things that
                are true independantly of which language or context/environment that it's used.
            </p><ol><li>Copy information from the code into the <a href="https://docs.google.com/spreadsheets/d/1kjyb0JGswSufELAKuy5jtuhs6I0ZyvY9Zwa5Nei6aAo/edit#gid=1093073527" target="_13wgsheet">SSoT Google Spreadsheet</a></li><li>Prototype a change in the code, which isolates the parts dealing with the new SSoT</li><li>Create a tool (or use an existing tool) which can write that kind of code (for the full set).</li><li>Update the "hand code" to call the "derived" version fo the code</li><li>Delete the hand code version</li><li>Rinse and Repeat</li></ol><p></p><div><p>
                Included next are examples of the kind of information which is usually embeeded in
                "source code" directly, but which are much better described outside of the code.
                Databases and Spreadsheets work well for SSoT - but there are many options for
                gathering SSoT data from. 
            </p></div><p>
                The kinds of data that were moved over to the SSoT are:
            </p><ul><li>First and foremost - the list of "ways" of looking at a turtle</li><li>Valid Turtle Commands (like move/turn/...)</li><li>Common Shapes (like Triangle and ThreeLines)</li><li>The specific commands for those shapes</li><li>See the <a href="https://docs.google.com/spreadsheets/d/1kjyb0JGswSufELAKuy5jtuhs6I0ZyvY9Zwa5Nei6aAo/edit#gid=1093073527" target="_13wgsheet">SSoT Google Spreadsheet</a> for more</li></ul><h3>Commands</h3><p>
                The "basic" Turtle is able to perform these commands.
            </p><ul><b>Move</b> (Distance) <br /><div style="font-size: 0.8em;">Moves the specified distance in whatever direction 'the turtle' is currently pointing.
                    </div><p></p><b>Turn</b> (Degrees) <br /><div style="font-size: 0.8em;">Turn the specified degrees from the current position
                    </div><p></p><b>PenUp</b> () <br /><div style="font-size: 0.8em;">Lift the pen off of the paper
                    </div><p></p><b>PenDown</b> () <br /><div style="font-size: 0.8em;">Put the pen down on the paper
                    </div><p></p><b>SetColor</b> (Color) <br /><div style="font-size: 0.8em;">Set the color of the pen
                    </div><p></p></ul><h3>Predefined Scripts</h3><p>
                The original article uses these simple commands to demonstrate 13 ways
                of looking at a turtlle.  In each example, he demonstrates the approach by
                drawing:
            </p><ol><li>A Triangle</li><li>Three Lines</li><li>A Polygon</li></ol><p></p><div><p>
                In Designing the single source of truth for this project, I call the first
                two examples "PredefinedScript".  This is a script which only uses the basic
                Turtle Commands to complete a certain sequence of steps (a "PredefinedScriptStep").
            </p></div><p>
                At this point in time, the SSoT for this project includes 3 Predefined
                Scripts.  They are:
            </p><ul><li><h5>Drawing a Triangle</h5><ol><li><b>Move</b> 100</li><li><b>Turn</b> 120</li><li><b>Move</b> 100</li><li><b>Turn</b> 120</li><li><b>Move</b> 100</li><li><b>Turn</b> 120</li></ol></li><li><h5>Drawing a ThreeLines</h5><ol><li><b>PenDown</b></li><li><b>SetColor</b> Black</li><li><b>Move</b> 100</li><li><b>PenUp</b></li><li><b>Turn</b> 90</li><li><b>Move</b> 100</li><li><b>Turn</b> 90</li><li><b>PenDown</b></li><li><b>SetColor</b> Red</li><li><b>Move</b> 100</li><li><b>PenUp</b></li><li><b>Turn</b> 90</li><li><b>Move</b> 100</li><li><b>Turn</b> 90</li><li><b>PenDown</b></li><li><b>SetColor</b> Blue</li><li><b>Turn</b> 45</li><li><b>Move</b> 100</li></ol></li></ul><h4>Future Functions</h4><p>
            Future "ways" beyond the original 13 sometimes extend or even create new behavior than originally supported.  For example,
            the following additional shapes could be supported by each of "the ways".
           </p><ul><li><h5>Drawing a Box</h5><ol><li><b>Move</b> 100</li><li><b>Turn</b> 90</li><li><b>Move</b> 100</li><li><b>Turn</b> 90</li><li><b>Move</b> 100</li><li><b>Turn</b> 90</li><li><b>Move</b> 100</li><li><b>Turn</b> 90</li></ol></li></ul><h4>Future Commands</h4><p>
                Some of the tools developed after the first 13 ways, also may have (or introduce) access to the 
                following additional "turtle" commands.
            </p><ul><b>DrawPolygon</b> (Sides) <br /><div style="font-size: 0.8em;">Turn the number of degrees based on the number of sides passed in - <small>suggested for v 2+</small></div><b>DrawLine</b> (Distance) <br /><div style="font-size: 0.8em;">Put the pen down, move distance and the left the pen up - <small>suggested for v 3+</small></div><b>TurnSide</b> (Sides) <br /><div style="font-size: 0.8em;">Turn the number of degrees based on the number of sides - <small>suggested for v 3+</small></div><b>Repeat</b> (Repeat) <br /><div style="font-size: 0.8em;">Repeats the previous N commands the specified number of times - <small>suggested for v 3+</small></div><b>Exec</b> (Command) <br /><div style="font-size: 0.8em;">Executes the given command - <small>suggested for v 3+</small></div></ul><h3>The Ways</h3><p>
                The purpose of this code is demonstrate different ways to solve the same problem. 
                Variations on a theme - listed below.
            </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 01 - OOTurtle</h5><div style="whitespace: pre-wrap"><i>Simple OO -- a class with mutable state</i></div><p></p><pre>In this design, a simple OO class represents the turtle,
and the client talks to the turtle directly.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 02 - FPTurtle</h5><div style="whitespace: pre-wrap"><i>Simple FP - a module of functions with immutable state</i></div><p></p><pre>In this design, the turtle state is immutable. A module contains functions that return a new turtle state,
and the client uses these turtle functions directly.

The client must keep track of the current state and pass it into the next function call.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 03 - Api_OO_Core</h5><div style="whitespace: pre-wrap"><i>API (OO Approach) -- OO API calling stateful core class</i></div><p></p><pre>In this design, an API layer communicates with a turtle class
and the client talks to the API layer.

The input to the API are strings, and so the API validates the
input and returns a Result containing any errors.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 04 - Api_FP_Core</h5><div style="whitespace: pre-wrap"><i>API (OO/FP hybrid approach) -- OO API calling stateless functions</i></div><p></p><pre>In this design, an API layer communicates with pure turtle functions
and the client talks to the API layer.

The API layer manages the state (rather than the client) by storing a mutable turtle state.

*This approach has been named \</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 05 - TurtleAgent</h5><div style="whitespace: pre-wrap"><i>API (hybrid approach) -- OO API posting messages to an Agent</i></div><p></p><pre>In this design, an API layer communicates with a TurtleAgent
and the client talks to the API layer.

Because the Agent has a message queue, all possible commands are managed with a
single discriminated union type (`TurtleCommand`).

There are no mutables anywhere. The Agent manages the turtle state by
storing the current state as a parameter in the recursive message processing loop.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 06 - DependencyInjection_Interface1</h5><div style="whitespace: pre-wrap"><i>Dependency injection (using interfaces) -- v1: OO interface</i></div><p></p><pre>In this design, an API layer communicates with a Turtle Interface (OO style) or a record of TurtleFunctions (FP style)
rather than directly with a turtle.
The client injects a specific turtle implementation via the API's constructor.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 06 - DependencyInjection_Interface2</h5><div style="whitespace: pre-wrap"><i>Dependency injection (using interfaces) - v2: records of functions</i></div><p></p><pre>In this design, an API layer communicates with a Turtle Interface (OO style) or a record of TurtleFunctions (FP style)
rather than directly with a turtle.
The client injects a specific turtle implementation via the API's constructor.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 07 - DependencyInjection_Functions1</h5><div style="whitespace: pre-wrap"><i>Dependency injection using functions (v1: pass in all functions)</i></div><p></p><pre>In this design, an API layer communicates via one or more functions that are passed in as parameters to the API call.
These functions are typically partially applied so that the call site is decoupled from the `injection`

No interface is passed to the constructor.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 07 - DependencyInjection_Functions2</h5><div style="whitespace: pre-wrap"><i>Dependency injection using functions (v2: pass in a single function)</i></div><p></p><pre>In this design, an API layer communicates via one or more functions that are passed in as parameters to the API call.
These functions are typically partially applied so that the call site is decoupled from the `injection`

No interface is passed to the constructor.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 08 - StateMonad</h5><div style="whitespace: pre-wrap"><i>Batch oriented -- Using a state monad (computation expression)</i></div><p></p><pre>In this design, the client uses the FP Turtle functions directly.

As before, the client must keep track of the current state and pass it into the next function call,
but this time the state is kept out of sight by using a State monad (called `turtle` computation expression here)

As a result, there are no mutables anywhere.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 09 - BatchCommands</h5><div style="whitespace: pre-wrap"><i>Batch oriented -- Using a list of commands</i></div><p></p><pre>In this design, the client creates a list of `Command`s that will be intepreted later.
These commands are then run in sequence using the Turtle library functions.

This approach means that there is no state that needs to be persisted between calls by the client.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 10 - EventSourcing</h5><div style="whitespace: pre-wrap"><i>Event sourcing -- Building state from a list of past events</i></div><p></p><pre>In this design, the client sends a `Command` to a `CommandHandler`.
The CommandHandler converts that to a list of events and stores them in an `EventStore`.

In order to know how to process a Command, the CommandHandler builds the current state
from scratch using the past events associated with that particular turtle.

Neither the client nor the command handler needs to track state.  Only the EventStore is mutable.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 11 - FRP</h5><div style="whitespace: pre-wrap"><i>Functional Retroactive Programming -- Business logic is based on reacting to earlier events</i></div><p></p><pre>In this design, the `write-side` follows the same pattern as the event-sourcing example.
A client sends a Command to a CommandHandler, which converts that to a list of events and stores them in an EventStore.

However in this design, the CommandHandler only updates state and does NOT do any complex business logic.

The domain logic is done on the \</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 12 - BranchingOnResponse</h5><div style="whitespace: pre-wrap"><i>Monadic control flow -- Making decisions in the turtle computation expression</i></div><p></p><pre>In this design, the turtle can reply to certain commands with errors.

The code demonstrates how the client can make decisions inside the turtle computation expression
while the state is being passed around behind the scenes.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 13 - InterpreterV1</h5><div style="whitespace: pre-wrap"><i>The interpreter pattern</i></div><p></p><pre>In this design, the client builds a data structure (`TurtleProgram`) that represents the instructions.

This Turtle Program can then interpreted later in various ways</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 13 - InterpreterV2</h5><div style="whitespace: pre-wrap"><i>The interpreter pattern</i></div><p></p><pre>In this design, the client builds a data structure (`TurtleProgram`) that represents the instructions.

This Turtle Program can then interpreted later in various ways</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 14 - AdtTurtle</h5><div style="whitespace: pre-wrap"><i>Abstract Data Turtle - a private type with an associated module of functions</i></div><p></p><pre>In this design, the details of the turtle structure is hidden from the client,
so the it could be changed without breaking any code.

See https://www.reddit.com/r/fsharp/comments/36s0zr/structuring_f_programs_with_abstract_data_types/?
for more on ADTs in F#.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 15 - CapabilityBasedTurtle</h5><div style="whitespace: pre-wrap"><i>API with capabilities</i></div><p></p><pre>In this design, the turtle exposes a list of functions (capabilities) after each action.
These are the ONLY actions available to the client

More on capability-based security at http://fsharpforfunandprofit.com/posts/capability-based-security/</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p><hr /><div style="font-size: 0.8em; margin-top: 1em;"><h5>Way 16 - TurtleCanvas</h5><div style="whitespace: pre-wrap"><i>Turtle Canvas</i></div><p></p><pre>This is a design which monitors the main `turtle` - and then runns the another turtle's tests.  

Each test is saved to a .png with the path traced by the turtle.</pre></div><p><b>Pros</b> ... coming soon.
                </p><p><b>Cons</b> ... coming soon.
                </p></div></body></html>